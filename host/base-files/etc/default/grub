##
## Multiverse OS: Universal Bootloader Configuration
###############################################################################
#
# Requires ability to generate bootloader configuration files for both host
# and virtual machine grub bootloaders which will be quite different.
#
###############################################################################

###############################################################################
#### Task List
###############################################################################
#### TODO: Add AMD support:
####		amd_iommu=pt
#### 		(and instead of vmx cpu feature, smx will be required) 
###############################################################################


###############################################################################
# Add virtual PCI subsystem & slots
###############################################################################
# This concept needs to be translated to portalgun, this is the
# device on the host machine:
#
# <device>
#   <name>pci_0000_00_00_0</name>
#
#   *(This is one the virtual functions specified by path)*
#   <path>/sys/devices/pci0000:00/0000:00:01.0/0000:00:00.0</path>
#
#   <parent>computer</parent>
#   <driver>
#     <name>e1000e</name>
#   </driver>
#   <capability type='pci'>
#     <domain>0</domain>
#     <bus>0</bus>
#     <slot>25</slot>
#     <function>0</function>
#     <product id='0x1502'>82579LM Gigabit Network Connection</product>
#     <vendor id='0x8086'>Intel Corporation</vendor>
#     <iommuGroup number='7'>
#       <address domain='0x0000' bus='0x00' slot='0x00' function='0x0' />
#     </iommuGroup>
#   </capability>
# </device>
#
#
# Translates to a PCI passthrough:
#
# <hostdev>
#   <source> 
#     <address domain='0' bus='0' slot='25' function='0' />
#   </source>
#   <rom bar='off' />  (lspci -v command to check the device for expansion rom)
#   (the rom can sometimes be bypassed for speed, or other issues related can 
#   prevent booting)
# </hostdev>
#
###############################################################################
# **Virtual function without the device**
# SR-IOV PCI Device, Virtual Functionality 
# Virtual functions provide data protection between virtual machines and 
# the physical server as data managed is controlled within the hardware. 
#
#
# <interface type="hostdev">
#   <driver name="vfio">
#   <source>
#     <address type="pci" domain="0x0000" bus="0x00" slot="0x00" 
#     function="0x0"/> (This one, the function, is the key peice, it can be 
#     passed through without the device, to create a virtual device with this
#     devices function. This concept is pretty game changing).
#   <mac address="">
#   
#   *(This is an optional addition to isolate the network)* 
#   <vlan>
#     <tag id='42'/>
#   </vlan>
#
#
#   <virtualport type="802.1Qbh">
#     <parameters profileid="finance"/>
#
#
###############################################################################


###############################################################################
# Hotplugging
###############################################################################
# Devices can be specified by themselves then plugged in **THIS CONCEPT IS
# ONE OF THE BEST LIBVIRT HAS TO OFFER. WE SHOULD REALLY IMPLEMENT THIS
# COCNEPT. 
#
# SO we define a ruby config file, to create a "device" and then this device
# can represent an actual device and be loaded and unloaded using this file.
#
# In the same way, perhaps we can define a debian ISO, this would contain the
# MAC address, the signatures, so it can be verified. 
#
# <interface type='network'>
#   <source network='passthrough'>
#   
# <network connections='1'>
#  <name>passthrough</name>
#  <uuid>xxxxx-xxxx-xxxx-xxxx</uuid>
#  <forward mode='hostdev' managed='yes'>
#   <pf dev='eth3'/>
#   <address type='pci' domain='0x0000' bus='0x00' slot='0x00' function='0x0'/>
#
# virt-install ...
#    ...
#    --initrd-inject /path/to/ks.cfg \
#    --extra-args="ks=file:/ks.cfg console=tty0 console=ttyS0,115200n88"
#
###############################################################################


###############################################################################
# PCI Passthrough using OVMF
###############################################################################
# Audio Device
# <qemu:commandline>
#   <qemu:arg value=""/>
# 	-aduiodev
# 	pa,id=snd0,server=unix:/tmp/pulse-socket
# 	{OR}
# 	pa,id=usb,server=unix:/tmp/pulse-socket,/tmp/pulse-socket,
# 	out.mixing-engnine=off
#
###############################################################################
# Another thing to look into is scream-ivshmem, a virtual audio driver but 
# does not work with secure boot (sometimes? need more research)
#
###############################################################################
# NVIDIA drivers
#  One issue with nvidia drivers is they may be looking for vendor_id on 
#  the hypervisor (closest one if nested), this is done via <features> <hyperv>
#  <vendor_id state='on' value='spoofed-realistic-value'/>
#
###############################################################################
# Use hypvervisor features
#   This gets a good preformance boost supposedly, use hypervclock, use 
#   <features> <hyperv> to set above, relaxed, vapic, <spinlocks state='on'
#   retries='8191' /> 
#
###############################################################################
# ACS Override patch: 
#     To bypass vfio groups to get finer grain control of indivdiual PCI 
#     devices can be passed through. This enables pass through a single device
#     in a group, for example an individual usb device can be passed through
#     instead of requiring an entire usb controller typically 3 usb slots on
#     a motherboard. 
#
#       ._____________________________________________________________.
#     	|  This may be better for the controller but not the host     |
#     	|_____________________________________________________________|
#
#    Options for `pcie_acs_override`:
#    	* [downstream] all downstream ports, full ACS capabilities.
#    	* [multifunction] all multifunciton devices - multifunction ACS subset.
#    	* [id:nnnn:nnnn] specific device - full ACS capabilities; specified 
#    	  as `vendor_id:device_id` in hex.
#
#   Both `downstream` and `multifunction` can be used together, so maximum
#   device granularity can be obtained by using the following configuration:
#   	
#   	`pcie_acs_override=downstream,multifunction`
#
#   For utilizing the OVMF firmware, use edk2-ovmf package, copy the UEFI 
#   variables from the shared location:
#
#   	`/usr/share/edk2-ovmf/x64//OVMF_VARS.fd`
#
#   Then copy this file to a temporary location and specify the OVMF paths 
#   by defining BIOS nvram very explicity:
#
#   	`-drive if=pflash,format=raw,readonly,file=/tmp/MY_VARS.fd`
#
#
#
#
###############################################################################
GRUB_DEFAULT=0
GRUB_TIMEOUT=5
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Multiverse OS: Bare-metal Host Machine`
GRUB_CMDLINE_LINUX_DEFAULT="quiet intel_iommu=on iommu=pt pci=realloc nosmt=force nomodeset isolcpus=1-6,11-16"
GRUB_CMDLINE_LINUX=""
###############################################################################
#
###############################################################################


###############################################################################
# Uncomment to enable BadRAM filtering, modify to suit your needs
# This works with Linux (no patch required) and with any kernel that obtains
# the memory map information from GRUB (GNU Mach, kernel of FreeBSD ...)
###############################################################################
#GRUB_BADRAM="0x01234567,0xfefefefe,0x89abcdef,0xefefefef"


###############################################################################
# Uncomment to disable graphical terminal (grub-pc only)
###############################################################################
GRUB_TERMINAL=console


###############################################################################
# The resolution used on graphical terminal
# note that you can use only modes which your graphic card supports via VBE
# you can see them in real GRUB with the command `vbeinfo'
###############################################################################
#GRUB_GFXMODE=640x480


###############################################################################
# Uncomment if you don't want GRUB to pass "root=UUID=xxx" parameter to Linux
###############################################################################
#GRUB_DISABLE_LINUX_UUID=true


###############################################################################
# Uncomment to disable generation of recovery mode menu entries
###############################################################################
#GRUB_DISABLE_RECOVERY="true"


